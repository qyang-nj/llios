# Mixed Language  Compiling
Mixed language module compiling is one of the mysterious things in terms of iOS building. Xcode usually handles it nicely, but rarely we understand what happens behind the scenes.

Although technically a module with Objective-C, C and C++ is a mixed language module, here we say a mixed language module is a module contains both Objective-C and Swift code. They are quite challenging because those two languages use different compilers (`clang` and `swiftc`) and have different interface formats (`.h` and `.swiftmodule`). Within a module, the interaction can be complicated. Swift can call Objc, Objc can call Swift, or completely entwined.

## Core Concepts
### .h

### module and module map

### .swiftmodule

## Inter-module compiling
For the sake of simplicity, we will discuss the case between two libraries. The process is almost identical between executable and library. For frameworks, since they are just libraries in a predefined directory structure, the underlying mechanism is the same.

### Swift uses Objc
The Objc module needs to provide a `module.modulemap` file. This module map can be either manually created or generated by a build system.
```
module MyObjcModule {
    umbrella header "MyObjcModule.h"
    export *
    module * { export * }
}
```
In Swift code, we simply import the module like a Swift one.
``` swift
// MySwiftModule.swift
@import MyObjcModule
```

To compile Swift code, we have to let the compiler know where to locate the `module.modulemap`. This is done by passing `-I` to `swiftc`.
```
swiftc ... -I/directory/of/module.modulemap MySwiftModule.swift ...
```

### Objc uses Swift
For this scenario, we need to deal with Swift module first. In Swift code, we annotate the classes or methods with `@objc`. For the obvious reason, the Swift-only features, e.g. struct, tuple, generic, cannot be used in Objc.
``` swift
// MySwiftModule.swift
@objc public class MySwiftMoulde {}
```
Then we need to let Swift compiler generate a header file that can be imported by a Objc module. This is done by using `-emit-objc-header`. By convention, this header file has `-Swift` suffix.
```
swfitc ... -emit-objc-header -emit-objc-header-path MySwiftModule-Swift.h MySwiftModule.swift ....
```
Now in the Objc module, we import this header file like a regular header.
``` objc
// MyObjcModule.m
#import <MySwiftModule/MySwiftModule-Swift.h>
```
To compile the Objc module, simple let `clang` know where to find the `*-Swift.h` file.
```
clang ... -I/directory/of/MySwiftModule-Swift.h MyObjcModule.m ...
```

## Intra-module compiling
### Objc uses Swift
Swift class needs to be marked as @objc.
```
// SwiftClass.swift
@objc public class SwiftClass : NSObject {}
```
Build
```
swiftc -c ... -emit-objc-header -emit-objc-header-path MixedModule-Swift.h
```

In objc .m file , include the generated -Swift head file
```
// ObjcClass.m
#include "MixedModule-Swift.h"
```

In objc .h file, use forward declaration instead of including header files.
```
// ObjcClass.h
@class SwiftMaterial;
```


### Swift uses Objc
Underlying module
```
-import-underlying-module -I Sources/MixedModule # for underlying module's module.modulemap
```

Bridging header
```
-import-objc-header Sources/MixedModule/MixedModule-Bridging-Header.h
```


## Notes
* Cannot use `-import-underlying-module` and `-import-objc-header` at the same time.
```
error: using bridging headers with framework targets is unsupported
```
* By default, the generated header contains interfaces for Swift declarations marked with the public or open modifier. Using `-emit-objc-header` with `-import-objc-header` make generated header also include interfaces marked with the internal modifier.
